decide() {
	return noise() > 0.;
}

fftFiForSourceSi(si, snFftWindowSize) {
	return floor(si / snFftWindowSize ) + 1;
}

wrapSi(si, sn) {
	return (si + sn) % sn;
}


// ===================================
// notation
// si -> sample index in source
// sn -> number of samples in source
// fi -> fft frame index in fftmap
// fn -> number of fft frames in fftmap
// ===================================
	
// ===================================
// parameters
// ===================================
Param snMaxKeyLen(10240);
Param snPosStartOffset(44100); // negative offset back
Param snPosEndOffset(44100); // negative offset back

Param snFftWindowSize(1024);

Param sourceChan(1);
Param guideChan(0);

Param dryWet(0.);

// ===================================
// external data
// ===================================

Buffer fftMag("rbFftMag");
Buffer fftPhase("rbFftPhase");

// ===================================
// internal data
// ===================================


//Data match(fnPosWidth);
Buffer match("dbgMatch");

fftMagSize = dim(fftMag); 

// ===================================
// inputs and derivatives
// ===================================

siHead = in1; //buffer head siHead -> drives fiPosStart, fnPosWidth, fiGuide
fiGuide = floor(siHead / snFftWindowSize) - 1; // index of last fully written fft frame
fiSource = fiGuide; // assume same heads for guide nd source for now

siPosStart = siHead + snPosStartOffset;
siPosEnd = siHead + snPosEndOffset;

fiPosStart = fftFiForSourceSi(siPosStart, snFftWindowSize);
fiPosEnd = fftFiForSourceSi(siPosEnd, snFftWindowSize);

fnPosWidth = max(1, fiPosEnd - fiPosStart);
fiPosStart = min(fiPosStart, fiGuide);


snGranuleSize = in2;


fnMaxKeyLen = ceil(snMaxKeyLen / snFftWindowSize);
if (fnMaxKeyLen == 0) {
	fnMaxKeyLen = 100000000;
}
fnKeyLen = min(ceil(snGranuleSize / snFftWindowSize), fnMaxKeyLen);


// ===================================
// stubs and TODOs
// ===================================
chan = 0;

// ===================================
// DEBUG
// ===================================
DEBUG_IN = in4;
DEBUG = -1;



// ----------------------------------
// DEBUG: debugging: indexing poc 
// PoC draw FFT index on scope: 
// find max freq in a frame at fiPosStart and debug_out its index
// ----------------------------------
maxM = -1;
maxMI = -1;
for (i = 0; i < snFftWindowSize; i += 1) {
	siRaw = wrapSi(fiPosStart * snFftWindowSize + i, fftMagSize);
	m = fftMag.peek(siRaw, guideChan);
	p = fftPhase.peek(siRaw, guideChan);
	if (maxM < m) {
		maxM = m;
		maxMI = i;
	}
} 
DEBUG_POC_FFT_INDEXING = maxMI;
DEBUG_SI_POS_START = wrapSi(fiPosStart * snFftWindowSize, fftMagSize);

// ===================================
// OLD LOGIC
// ===================================

// // TODO: ?????
// // 1. process / cache fiGuide @ guideChan
// // 2. 

// // calculate raw match
// for (i = 0; i < fnPosWidth; i += 1) {

// 	rawI = ((fiPosStart + i) * snFftWindowSize + targetFreqBin);
// 	sourceFreqA = fftMag.peek(rawI % fftMagSize, sourceChan);
// 	if (i == 0) {
// 		//	DEBUG = sourceFreqA;
// 	}
// 	m = sourceFreqA;
// 	match.poke(m, i, chan);
// }


// curKeyV = 0;

// // normalize, frame-agg, integrate match
// matchSum = 0;
// popElement = 0;


// for (i = 0; i < fnPosWidth; i += 1) {

// 	curKeyV += match.peek(i, chan) - popElement;
// 	targetI = i - fnKeyLen + 1;
// 	if (targetI >= 0) {
// 		popElement = match.peek(targetI, chan);
// 		matchSum += curKeyV;
// 		match.poke(curKeyV, targetI, chan);
// 	}
// }


// mean = matchSum / (fnPosWidth - fnKeyLen + 1);

// roll = 0.9 * matchSum / mean;

// scaledMatchSum = 0;
// for (i = 0; i < fnPosWidth - fnKeyLen + 1; i += 1) {
// 	f = match.peek(i, chan) / mean;
// 	scaledF = max(0, (f - mean) * (dryWet + 1.) + mean);
// 	scaledMatchSum += scaledF;
// 	match.poke(scaledF, i, chan);
// }


// roll = ((noise() + 1.) / 2.) * scaledMatchSum;

// grainPositionWs = 0;

// for (i = 0; i < fnPosWidth - fnKeyLen + 1; i += 1) {
// 	roll -= match.peek(i, chan);
// 	if (roll <= 0) {
// 		grainPositionWs = i;
// 		break;
// 	}
// }


// debugIndex = ((fiPosStart + grainPositionWs) * snFftWindowSize + targetFreqBin) % fftMagSize;

// //DEBUG = fftMag.peek(debugIndex, sourceChan);
// //DEBUG = debugIndex;
// //z,DEBUG = peek(fftMag, 0, channels=2);
// //DEBUG = fftMag.peek(44031, 1);



// out1 = ((fiPosStart + grainPositionWs) * snFftWindowSize) % fftMagSize; // todo: randomize?

out1 = -1;
out2 = DEBUG_POC_FFT_INDEXING;

