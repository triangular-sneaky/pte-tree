decide() {
	return noise() > 0.;
}

Param maxKeyLenSamps(10240);
// Param firstWs(0);
Param posWidthSamps(4410);

Param fftWindowSize(1024);

// Param targetFreqBin(0);

Param dryWet(0.5);

Buffer freqMap("rbFreqMap");

//Data match(posWidthWs);
Buffer match("dbgMatch");

firstSamps = in1;
firstWs = ceil(firstSamps / fftWindowSize);

granuleSizeSamps = in2;


maxKeyLenWs = ceil(maxKeyLenSamps / fftWindowSize);
if (maxKeyLenWs == 0) {
	maxKeyLenWs = 100000000;
}

keyLenWs = min(ceil(granuleSizeSamps / fftWindowSize), maxKeyLenWs);



targetFreqBin = in3;

posWidthWs = floor(posWidthSamps / fftWindowSize);


//DEBUG
out2 = posWidthWs;

// calculate raw match
matchNormDivider = 0.;

for (i = 0; i < posWidthWs; i+= 1) {
	
	
	sourceFreqA = peek(freqMap, (firstWs + i) * fftWindowSize + targetFreqBin);
	m = sourceFreqA;
	matchNormDivider += m;
	poke(match, m, i);
}

curKeyV = 0;
maxKeyV = 0;
maxKeyI = 0;

// normalize and randomize match
for (i = 0; i < posWidthWs; i+= 1) {

	normalizedM = peek(match, i) / matchNormDivider;
	r01 = (noise() + 1.) / 2.;
	
	s = normalizedM * dryWet + r01 * (1 - dryWet);
	poke(match, s, i);
}


	
for (i = 0; i < posWidthWs; i+= 1) {
		
	curKeyV += peek(match, i);
	if (i >= keyLenWs) {
			curKeyV -= peek(match, i - keyLenWs);
	}
	if (curKeyV > maxKeyV || curKeyV == maxKeyV && decide()) {
			maxKeyV = curKeyV;
			maxKeyI = i - keyLenWs + 1; 
	}
}

out1 = maxKeyI;