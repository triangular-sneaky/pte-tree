decide() {
	return noise() > 0.;
}

fftWiForSourceSi(si, snFftWindowSize) {
	return floor(si / snFftWindowSize ) + 1;
}
// notation
// si -> sample index in source
// sn -> number of samples in source
// wi -> fft window index in fftmap
// wn -> number of fft windows in fftmap
	
Param snMaxKeyLen(10240);
Param snPosStartOffset(44100); // negative offset back
Param snPosEndOffset(44100); // negative offset back

Param snFftWindowSize(1024);

Param sourceChan(1);
Param guideChan(0);

Param dryWet(0.);

Buffer freqMap("rbFreqMap");
Buffer fftPhase("rbFftPhase");

//Data match(wnPosWidth);
Buffer match("dbgMatch");

freqMapSize = dim(freqMap);
// inputs and derivatives
// in1: buffer head siHead -> drives wiPosStart, wnPosWidth, wiGuide
siHead = in1;
wiGuide = floor(siHead / snFftWindowSize) - 1; // index of last fully written fft window

siPosStart = siHead + snPosStartOffset;
siPosEnd = siHead + snPosEndOffset;

wiPosStart = fftWiForSourceSi(siPosStart, snFftWindowSize);
wiPosEnd = fftWiForSourceSi(siPosEnd, snFftWindowSize);

wnPosWidth = max(1, wiPosEnd - wiPosStart);
wiPosStart = min(wiPosStart, wiGuide);

snGranuleSize = in2;

DEBUG = -1;

DEBUG_IN = in4;

chan = 0;

wnMaxKeyLen = ceil(snMaxKeyLen / snFftWindowSize);
if (wnMaxKeyLen == 0) {
	wnMaxKeyLen = 100000000;
}

wnKeyLen = min(ceil(snGranuleSize / snFftWindowSize), wnMaxKeyLen);

// 1. process / cache wiGuide @ guideChan
// 2. 

maxBinV = -1;
maxBin = -1;

// DEBUG: verify fft indexing
for (i = 0; i < wnPosWidth * snFftWindowSize; i += 1) {
	rawI = (wiPosStart * snFftWindowSize + i);
	v = freqMap.peek(rawI % freqMapSize, sourceChan);
	p = fftPhase.peek(rawI % freqMapSize, sourceChan);
	if (p != i % snFftWindowSize) {
		DEBUG = i;
	}
}

// calculate raw match
for (i = 0; i < wnPosWidth; i += 1) {

	rawI = ((wiPosStart + i) * snFftWindowSize + targetFreqBin);
	sourceFreqA = freqMap.peek(rawI % freqMapSize, sourceChan);
	if (i == 0) {
		//	DEBUG = sourceFreqA;
	}
	m = sourceFreqA;
	match.poke(m, i, chan);
}


curKeyV = 0;

// normalize, window-agg, integrate match
matchSum = 0;
popElement = 0;


for (i = 0; i < wnPosWidth; i += 1) {

	curKeyV += match.peek(i, chan) - popElement;
	targetI = i - wnKeyLen + 1;
	if (targetI >= 0) {
		popElement = match.peek(targetI, chan);
		matchSum += curKeyV;
		match.poke(curKeyV, targetI, chan);
	}
}


mean = matchSum / (wnPosWidth - wnKeyLen + 1);

roll = 0.9 * matchSum / mean;

scaledMatchSum = 0;
for (i = 0; i < wnPosWidth - wnKeyLen + 1; i += 1) {
	f = match.peek(i, chan) / mean;
	scaledF = max(0, (f - mean) * (dryWet + 1.) + mean);
	scaledMatchSum += scaledF;
	match.poke(scaledF, i, chan);
}


roll = ((noise() + 1.) / 2.) * scaledMatchSum;

grainPositionWs = 0;

for (i = 0; i < wnPosWidth - wnKeyLen + 1; i += 1) {
	roll -= match.peek(i, chan);
	if (roll <= 0) {
		grainPositionWs = i;
		break;
	}
}


debugIndex = ((wiPosStart + grainPositionWs) * snFftWindowSize + targetFreqBin) % freqMapSize;

//DEBUG = freqMap.peek(debugIndex, sourceChan);
//DEBUG = debugIndex;
//z,DEBUG = peek(freqMap, 0, channels=2);
//DEBUG = freqMap.peek(44031, 1);



out1 = ((wiPosStart + grainPositionWs) * snFftWindowSize) % freqMapSize; // todo: randomize?


out2 = DEBUG;

