decide() {
	return noise() > 0.;
}

_wrap(value, cap) {
	zuppo = value + cap;
	return zuppo % cap;
}

// TODO: redo
ssiToSfi(ssi, snFftWindowSize, data, nSourceChans) {
	return floor( (ssi - data.peek(ssi, getFrameChanI(nSourceChans))) / snFftWindowSize );
}

// TODO: redo
sfiToBinAddress(sfi, binIndex, snFftWindowSize, bufferSize) {
	return _wrap(((sfi + 1) * snFftWindowSize + binIndex), bufferSize);
}

// get 0-based source chan index
getSourceChanI(section, sourceChanRelI, nSourceChans) {
	return (nSourceChans + 1) * section + sourceChanRelI + 1;
}

getGuideChanI(section, nSourceChans) {
	return (nSourceChans + 1) * section;
}

getFrameChanI(nSourceChans) {
	return (nSourceChans + 1)*3;
}

assertEq(textIndex, a, b) {
	if (a == b) {
		return 0;
	} else return textIndex;
}

// ===================================
// notation
// ssi -> sample (value) index in wave
// sn -> number of samples in wave
// sfi -> frame index in source
// fn -> number of fft wave


// ===================================
	
// ===================================
// parameters
// ===================================
Param snMaxKeyLen(10240);
Param snPosStartOffset(0); // negative offset back
Param snPosEndOffset(0); // negative offset back

Param snFftWindowSize(1024);

// number of source chans
Param nSourceChans(3);

Param dryWet(0.);

// ===================================
// external data
// ===================================

Buffer data("rbGranularData");

// ===================================
// internal data
// ===================================


//Data match(fnPosWidth);
Buffer match("dbgMatch");

// sections
S_WAV = 0;
S_MAG = 1;
S_PHASE = 2;

dataSize = dim(data);
fnTotal = dataSize / snFftWindowSize;

// ===================================
// inputs and derivatives
// ===================================

siGuideHead = in1;// TODO: separate guide/source indexing
siSourceHead = in1; //buffer head siSourceHead -> drives fiPosStart, fnPosWidth, fiGuideHead
fiGuideHead = ssiToSfi(_wrap(siGuideHead - 2*snFftWindowSize, dataSize),snFftWindowSize, data, nSourceChans) ; // index of last fully written fft frameframe
fiSourceHead = fiGuideHead; // TODO: separate guide/source indexing

siPosStart = siSourceHead + snPosStartOffset;
siPosEnd = siSourceHead + snPosEndOffset;

fiPosStart = ssiToSfi(siPosStart, snFftWindowSize, data, nSourceChans);
fiPosEnd = ssiToSfi(siPosEnd, snFftWindowSize, data, nSourceChans);

fiPosStart = min(fiPosStart, fiSourceHead);
fiPosEnd = min(fiPosEnd, fiSourceHead);
fnPosWidth = max(1, fiPosEnd - fiPosStart);

// TODO: keylen???
//snGranuleSize = in2;

// fnMaxKeyLen = ceil(snMaxKeyLen / snFftWindowSize);
// if (fnMaxKeyLen == 0) {
// 	fnMaxKeyLen = 100000000;
// }
// fnKeyLen = min(ceil(snGranuleSize / snFftWindowSize), fnMaxKeyLen);


// ===================================
// stubs and TODOs
// ===================================
chan = 0;

// ===================================
// DEBUG
// ===================================
DEBUG_IN = in4;
DEBUG_0 = 0.;
DEBUG_1 = 0.;
DEBUG_2 = 0.;
DEBUG_3 = 0.;


// ----------------------------------
// DEBUG: debugging: indexing poc 
// PoC draw FFT index on scope: 
// find max freq in a frame at fiPosStart and debug_out its index
// NOTE: intentionally using source pos on guide chan. this wont stand later
// ----------------------------------
maxM = -1.;
maxMI = -1;
for (i = 0; i < snFftWindowSize; i += 1) {
	binAddress = sfiToBinAddress(fiPosStart, i, snFftWindowSize, dataSize);
	m = data.peek(binAddress, getGuideChanI(S_MAG, nSourceChans));
	if (maxM < m) {
		maxM = m;
		maxMI = i;
	}
} 
DEBUG_POC_FFT_INDEXING = maxMI;
DEBUG_SANITY_0 = dataSize;
DEBUG_0_BIN_ADDRESS = sfiToBinAddress(fiPosStart, 0, snFftWindowSize, dataSize);
DEBUG_0_BIN_VALUE = data.peek(DEBUG_0_BIN_ADDRESS, getGuideChanI(S_MAG, nSourceChans));

DEBUG_0 = DEBUG_POC_FFT_INDEXING;
DEBUG_1 = DEBUG_0_BIN_ADDRESS;
DEBUG_2 = 0;
DEBUG_3 = maxM;

out1 = -1;



// ===================================
// OLD LOGIC
// ===================================

// // TODO: ?????
// // 1. process / cache fiGuideHead @ guideChan
// // 2. 

// // calculate raw match
// for (i = 0; i < fnPosWidth; i += 1) {

// 	rawI = ((fiPosStart + i) * snFftWindowSize + targetFreqBin);
// 	sourceFreqA = fftMag.peek(rawI % fftMagSize, sourceChan);
// 	if (i == 0) {
// 		//	DEBUG = sourceFreqA;
// 	}
// 	m = sourceFreqA;
// 	match.poke(m, i, chan);
// }


// curKeyV = 0;

// // normalize, frame-agg, integrate match
// matchSum = 0;
// popElement = 0;


// for (i = 0; i < fnPosWidth; i += 1) {

// 	curKeyV += match.peek(i, chan) - popElement;
// 	targetI = i - fnKeyLen + 1;
// 	if (targetI >= 0) {
// 		popElement = match.peek(targetI, chan);
// 		matchSum += curKeyV;
// 		match.poke(curKeyV, targetI, chan);
// 	}
// }


// mean = matchSum / (fnPosWidth - fnKeyLen + 1);

// roll = 0.9 * matchSum / mean;

// scaledMatchSum = 0;
// for (i = 0; i < fnPosWidth - fnKeyLen + 1; i += 1) {
// 	f = match.peek(i, chan) / mean;
// 	scaledF = max(0, (f - mean) * (dryWet + 1.) + mean);
// 	scaledMatchSum += scaledF;
// 	match.poke(scaledF, i, chan);
// }


// roll = ((noise() + 1.) / 2.) * scaledMatchSum;

// grainPositionWs = 0;

// for (i = 0; i < fnPosWidth - fnKeyLen + 1; i += 1) {
// 	roll -= match.peek(i, chan);
// 	if (roll <= 0) {
// 		grainPositionWs = i;
// 		break;
// 	}
// }


// debugIndex = ((fiPosStart + grainPositionWs) * snFftWindowSize + targetFreqBin) % fftMagSize;

// //DEBUG = fftMag.peek(debugIndex, sourceChan);
// //DEBUG = debugIndex;
// //z,DEBUG = peek(fftMag, 0, channels=2);
// //DEBUG = fftMag.peek(44031, 1);



// out1 = ((fiPosStart + grainPositionWs) * snFftWindowSize) % fftMagSize; // todo: randomize?





// ====== TEST SECTION ==============
TEST_IN = in6;
testFailures = 0;

if (TEST_IN == 1) {
	testFailures += assertEq(0x1, 0, getGuideChanI(S_WAV, nSourceChans));
	testFailures += assertEq(0x2, 4, getGuideChanI(S_MAG, nSourceChans));
	testFailures += assertEq(0x4, 1, getSourceChanI(S_WAV, 0, nSourceChans));
	testFailures += assertEq(0x8, 6, getSourceChanI(S_MAG, 1, nSourceChans));
	testFailures += assertEq(0x10, 12, getFrameChanI(nSourceChans));

	testFailures += assertEq(0x20, 16, data.peek(
		sfiToBinAddress(
			ssiToSfi(2000, snFftWindowSize, data, nSourceChans),
			16,
			snFftWindowSize,
			dataSize), 
			getFrameChanI(nSourceChans)
	));
	
}
out6 = testFailures;

// ====== /TEST SECTION ==============
out2 = DEBUG_0;
out3 = DEBUG_1;
out4 = DEBUG_2;
out5 = DEBUG_3;
